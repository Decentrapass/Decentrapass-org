{"ast":null,"code":"import { IF } from \"../components/Constants/AddInterfaces\";\nimport { TYPES } from \"../components/Constants/constants\";\nexport const formatCard = card => {\n  let result = \"\";\n\n  for (let i = 0; i < card.length; i += 4) {\n    result += card.substring(i, i + 4) + \" \";\n  }\n\n  return result.substring(0, result.length - 1);\n};\nexport async function formatData(numItems, contract, acc) {\n  let arr = [];\n  let count = 0;\n\n  for (let i = 0; i < numItems; i++) {\n    let itemData = await contract.objects(acc, i).call();\n    let type = itemData[0];\n\n    if (itemData[1] != \"\") {\n      let ipfsData;\n      let url = \"https://gateway.ipfs.io/ipfs/\" + itemData[1];\n      let res = await fetch(url);\n      ipfsData = await res.text();\n      let receivedData = ipfsData.split(\",\");\n      let data = {\n        numId: count++,\n        id: i,\n        type: TYPES[type]\n      };\n      let correspondingIF = Object.keys(IF[TYPES[type]]);\n\n      for (let j = 0; j < receivedData.length; j++) {\n        data[correspondingIF[j]] = receivedData[j];\n      }\n\n      arr.push(data);\n    }\n  }\n\n  return arr;\n}\nexport function formatItem(type, item, id, nextId) {\n  let data = {\n    numId: id,\n    id: nextId,\n    type: TYPES[type]\n  };\n  let correspondingIF = Object.keys(IF[TYPES[type]]);\n\n  for (let j = 0; j < item.length; j++) {\n    data[correspondingIF[j]] = item[j];\n  }\n\n  return data;\n}\nexport function formatSend(data) {\n  let str = \"\";\n\n  for (const item of data) {\n    str += item + \",\";\n  }\n\n  return str.substring(0, str.length - 1);\n}\nexport function formatAccount(acc, n) {\n  acc = acc || \"\";\n  let shortAcc = acc.substring(0, n + 2) + \"...\" + acc.substring(acc.length - n, acc.length);\n  return shortAcc;\n}","map":{"version":3,"sources":["/home/danielmelchor/Documents/CodeProjects/Decentrapass/Website/src/functions/format.js"],"names":["IF","TYPES","formatCard","card","result","i","length","substring","formatData","numItems","contract","acc","arr","count","itemData","objects","call","type","ipfsData","url","res","fetch","text","receivedData","split","data","numId","id","correspondingIF","Object","keys","j","push","formatItem","item","nextId","formatSend","str","formatAccount","n","shortAcc"],"mappings":"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","sourcesContent":["import { IF } from \"../components/Constants/AddInterfaces\";\nimport { TYPES } from \"../components/Constants/constants\";\n\nexport const formatCard = (card) => {\n  let result = \"\";\n  for (let i = 0; i < card.length; i += 4) {\n    result += card.substring(i, i + 4) + \" \";\n  }\n  return result.substring(0, result.length - 1);\n};\n\nexport async function formatData(numItems, contract, acc) {\n  let arr = [];\n  let count = 0;\n  for (let i = 0; i < numItems; i++) {\n    let itemData = await contract.objects(acc, i).call();\n\n    let type = itemData[0];\n\n    if (itemData[1] != \"\") {\n      let ipfsData;\n      let url = \"https://gateway.ipfs.io/ipfs/\" + itemData[1];\n\n      let res = await fetch(url);\n      ipfsData = await res.text();\n\n      let receivedData = ipfsData.split(\",\");\n\n      let data = {\n        numId: count++,\n        id: i,\n        type: TYPES[type],\n      };\n\n      let correspondingIF = Object.keys(IF[TYPES[type]]);\n\n      for (let j = 0; j < receivedData.length; j++) {\n        data[correspondingIF[j]] = receivedData[j];\n      }\n\n      arr.push(data);\n    }\n  }\n\n  return arr;\n}\n\nexport function formatItem(type, item, id, nextId) {\n  let data = {\n    numId: id,\n    id: nextId,\n    type: TYPES[type],\n  };\n\n  let correspondingIF = Object.keys(IF[TYPES[type]]);\n\n  for (let j = 0; j < item.length; j++) {\n    data[correspondingIF[j]] = item[j];\n  }\n\n  return data;\n}\n\nexport function formatSend(data) {\n  let str = \"\";\n  for (const item of data) {\n    str += item + \",\";\n  }\n  return str.substring(0, str.length - 1);\n}\n\nexport function formatAccount(acc, n) {\n  acc = acc || \"\";\n  let shortAcc =\n    acc.substring(0, n + 2) + \"...\" + acc.substring(acc.length - n, acc.length);\n\n  return shortAcc;\n}\n"]},"metadata":{},"sourceType":"module"}